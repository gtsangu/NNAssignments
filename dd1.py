import numpy as np

x = np.array([
    [0.,  6.,  7.,  6.,  3.,  1., 10.,  5.,  9., 10.],
    [7.,  6.,  0.,  5.,  6.,  8.,  2.,  1.,  9., 10.],
    [2.,  3.,  5.,  3.,  8.,  9.,  0.,  6.,  7.,  4.],
    [1.,  5.,  3.,  7.,  3.,  8.,  8.,  0.,  9.,  9.],
    [2., 10.,  3.,  5.,  6.,  7.,  6.,  4.,  2., 10.],
    [2.,  4.,  9.,  1.,  1.,  2.,  1.,  9.,  4.,  1.],
    [2.,  6.,  7.,  2.,  3.,  7.,  9.,  7.,  3.,  0.],
    [3.,  2.,  1.,  1.,  6.,  6.,  9.,  7.,  7.,  5.],
    [5., 10.,  3.,  8., 10.,  9.,  3.,  4.,  5.,  9.],
    [1.,  6.,  6.,  3.,  4.,  3.,  3.,  9.,  4.,  3.]])


f_w = np.array([
    [10.,  4.,  9.,  9.,  7.],
    [2.,  7.,  7.,  2.,  1.],
    [6.,  3.,  5.,  4.,  1.],
    [7., 10.,  2.,  2.,  8.],
    [4.,  5.,  5.,  5.,  1.]])

f_b = 1

stride = 1


def relu(x):
    return max(0, x)


result = []

for xrow in range(0, len(x), stride):
    # ვჩერდებით, თუ ფილტრი დაბლა ჩაცდა მოცემულ მატრიცს
    if xrow + len(f_w) > len(x):
        break

    resultRow = []
    for xcol in range(0, len(x[0]), stride):
        # ვჩერდებით, თუ ფილტრი გაცდა მარჯვნივ მოცემულ მატრიცს
        if xcol + len(f_w[0]) > len(x[0]):
            break

        sumwx = 0
        # გადავყვებით ფილტრში ყველა წონას
        for frow in range(len(f_w)):
            for fcol in range(len(f_w[0])):
                # ვითვლით სკალარულ ნამრავლს xrow, xcol-დან დაწყებული 5x5 ფანჯრისთვის
                sumwx += f_w[frow][fcol]*x[frow + xrow][fcol + xcol]

        # ვუმატებთ bias-ს და ვატარებთ აქტივაციის ფუნქციაში
        output = relu(sumwx + f_b)

        # შედეგი რიცხვი ჩაჯდება პასუხის შესაბამის ინდექსზე
        resultRow.append(output)

    # შედეგი რიგი ჩაჯდება შესაბამის ინდექსზე
    result.append(resultRow)

print(result)

# result:
# [506.0, 599.0, 696.0, 643.0, 732.0, 752.0],
# [580.0, 648.0, 562.0, 612.0, 588.0, 724.0],
# [487.0, 661.0, 597.0, 609.0, 661.0, 614.0],
# [481.0, 598.0, 627.0, 624.0, 656.0, 735.0],
# [577.0, 669.0, 610.0, 652.0, 668.0, 723.0],
# [595.0, 547.0, 513.0, 584.0, 715.0, 690.0]]
